\documentclass[11pt]{article}
\title{\textbf{CS 374 Spring 2018\\Homework 5}}
\author{Nathaniel Murphy (njmurph3@illinois.edu)\\
		Tanvi Modi (tmodi3@illinois.edu)\\
		Marianne Huange (mhuang46@illinois.edu)}
\date{}

\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{color}

\lstset{tabsize=4,
		language=Python,
		keywordstyle=\color{blue},
		commentstyle=\color{red},
		basicstyle={\ttfamily},
		numbers=left
}

\begin{document}
\maketitle
\
\begin{lstlisting}
def merge_count_double(A, B):
	count = 0
	ret = []
	temp_B = [2*i for i in B]		## Double every value in array B
	
	while len(A) > 0 and len(temp_B) > 0:
		if A[0] <= temp_B[0]:
			A.pop(0)
		else:
			temp_B.pop(0)
			count += len(A)
	return count
	
def mergesort_count_double(A, lo, hi):
	if lo - hi >= 0:
		return 0
	mid = (lo+hi) // 2				## Find middle element
	a = mergesort_count_double(A, lo, mid)
	b = mergesort_count_double(A, mid+1, hi)
	return a + b + merge_count_double(A[lo:mid+1], A[mid+1:hi+1])
\end{lstlisting}
\ \\ \\
The language that I test this algorithm and that is very intuitive (almost looks like pseudocode) is Python. Note that we use variables with capital letters (i.e. A, B) to denote arrays. This algorithm looks almost identical to the algorithm discussed in Lab 10 except we multiply array B in the \texttt{merge\_count\_double} function by 2 which will ensure that $a_i > 2a_j$ for $i<j$. The \texttt{.pop(0)} notation used in \texttt{merge\_count\_double} represents removing and returning the first element of the array. Assuming that \texttt{.pop(0)} takes $\mathcal{O}(1)$ time and instantiation of \texttt{temp\_B} takes $\mathcal{O}(\frac{n}{2})$ time which means that \texttt{merge\_count\_double} runs in approximately $\mathcal{O}(\frac{3n}{2})=\mathcal{O}(n)$ time which is identical to the regular mergesort algorithm. Thus, \texttt{mergesort\_count\_double} runs in $\mathcal{O}(n\log{}n)$.
\end{document}